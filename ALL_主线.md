
## 业务快速迭代
业务稳定性
业务灾备（快速恢复）
雪崩等极端情况，提供基本服务。
新技术的应用以及老旧系统处理。
人员配置：前端，后端，测试，产品，运营等；
A岗 B岗
后备人员培养

------出现问题需要解决问题，先回答三个问题：
1.需求提出者需要解决什么问题
2.你解决的是什么问题
3.有没有更加好的办法

高可用是如何实现，如何保证高可用
高性能是如何实现，瓶颈在哪里


## 前端
JS
vue 界面button 等可以使用原生功能

## 客户端
安卓
IOS

## 后端
【golang】
1.hashmap结构
2.def  iterface

## C++
-----------------
## java
hashmap
jvm垃圾回收；
jvm性能调优
java spring框架（ioc aop）
java 代理  （1.静态代理 2.动态代理 3.Cglib代理）
以及反射
synchronized 关键词
hashmap 结构
jvm优化：常见内存溢出   堆 栈 垃圾回收

根据垃圾回收机制的不同，java堆有可能拥有不同的结构，常见的java堆分为新生代和老年代，目前还有永久代。其中新生代存放刚创建的对象及年龄不大的对象，老年带存放着在新生代中经历过多次回收后还存在的对象。
对象晋升过程：
新生代分为eden区s0,s1区（from，to）。多数情况下对象首先分配在eden区，在一次新生代回收后，存活下来的对象存入s0或s1区。每经过一次新生代的回收，对象的年龄加1。默认情况下年龄达到15的对象将晋升至老年代。如果在第一次回收的时候，存活的对象大于s0（s1）空间，将直接晋升至老年代，如果在为对象第一次分配空间时，对象空间大于eden空间的话，对象也直接分配到老年代。

（1）堆溢出：设置-Xmx调整最大可用堆空间
（2）直接内存溢出：可能是系统内存空间不足，同时没达到参数默认的上限，没有触发GC导致OOM，解决方法是通过-XX:MaxDirectMemorySize 来限制最大内存
(3)过多线程导致OOM：由于每开启一个线程都会给这个线程分配一个栈，因此当线程数达到一定程度，系统空间不足的时候就会内存溢出，可以尝试减少堆空间，或者可以通过设置参数-Xss限制每个栈的大小。
(4)永久区溢出：系统加载的类过多，导致永久区溢出，通过-XX:MaxPermSize来设置永久区最大可用空间。
(5)GC效率低下引起的OOM：GC是内存回收的关键，回收效率低很有可能引起内存溢出，可以通过合理的分配堆（包括新生代和老年代）空间去解决。


String造成的内存泄漏
内存泄漏是指，不再使用的对象占据内存不释放，导致可用内存不断减小，最终引起内存泄漏。在Java1.6中String.subString()方法就存在这样的问题。



## 机器linux性能调优：
top
iostat
free


## 存储
oracle
mysql
mongdb
PQ
redis
tair


## 算法数据结构：
二叉树，排序算法
哈希表
（左程云）算法1：实现一个特殊的栈，在实现的栈的基础功能上，再实现返回栈的最小元素的操作（要求1：pop，push，getMin 操作时间复杂度为O(1),设计的栈结构可以使用现成的栈结构）



## 网络传输
TCP：
tcp三次握手以及四次挥手，tcp黏连出现解决
UPD
HTTP：
http协议各个常用字段以及返回值意义
http GET POST 区别

## 架构
前中后
分层架构



## 项目说明：
消息推送系统：用户中心设备列表（快队列，慢队列） 日志系统  CMS系统，日志查询；
消息的推送保证（conn与sdk保障，sdk回复，删除消息；否则一直存储，离线消息以及在线消息；消息推送列表，用户可以直接查看，所有消息。）
消息一致性保证，消息分级；

短信系统：选型golang redis做队列；（本地redis队列和远端redis队列做缓存）灾备考虑
，
，，
